\section{Analysis} % (fold)
\label{sec:analysis}

In this section we will analyze and describe our approach on implementing Raft with relation to the purpose of this project and with relation to acheive a more fault-tolerant and robust implementation.

\subsection{Existing Raft Implementations} % (fold)
\label{sub:existing_raft_implementations}

The application of consensus algorithms such as Raft is many, but the most generic applications are databases and service discovery systems. As Raft mostly fits applications in the low level end of the stack, it will also be best suited to be implemented in a more low level and light language such as C, C++ or Go. Erlang would also be a great fit with its fault-tolerant features.

Raft have already been implemented in several versions and in many languages. Diego Ongaro himself has implemented Raft in C++ (LogCabin\footnote{https://github.com/logcabin/logcabin}), CoreOS\footnote{A new Linux operation system fork made for server deployments.} uses etcd\footnote{https://github.com/coreos/etcd}, which is a Raft implementation in Go used for service discovery.

If a Raft implementation was needed for real usage, the solution would have been to extend some of the rich open source implementations already available in solid languages as Go and C. But as mentioned in the introduction, the scope of this project is to learn about Raft with relation to fault-tolerance by implementing it. To be able to cover as much of Raft as possible in the time scope, that language chosen for implementation is JavaScript, because it would allow more productivity.

% subsection existing_raft_implementations (end)

\subsection{Testing} % (fold)
\label{sub:testing}

In order to be able to verify that the implementation satisfies the requirements and that to ensure a higher level of robustness, the software will be throughly tested. To document requirement satisfaction, the implementation will be black-box tested on the level of acceptance and integration.

In order to acheive robustness the implementation will also be white-box tested on the unit test level in order to test the behaviour of the different objects in situations and cases that are hard to foresee.

% subsection testing (end)

% section analysis (end)
