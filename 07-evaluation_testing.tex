\section{Evaluation and Testing} % (fold)
\label{sec:evaluation_and_testing}
As mentioned in the analysis section\ref{sec:analysis} we are to evaluate our solution with white- and black box tests. Their description will thus be provided followed by the results.

%Skriv videre om...

\subsection{White box tests}
The development of our solution was iterate and based on the behaviour of Raft. This included writing a test for each behaviour described in the condensed summary of Raft\cite{Raft}. For each of these tests its required functionality was then implemented in order to pass its repsective test. 

%Forklar heraf resulterne af testene, og hvilke dele af koden der hÃ¸rer til hvilken 'behaviour'.

\subsection{Black box test scenarios}
Verifying that our solution actually is an implementation of Raft requires more cohesive tests in the form of validating that we uphold the properties that are argued to provide consensus. This is done by constructing a set of scenarios that reflects the behaviour of the components of Raft: Leader Election, Log Replication, and Safety. The scenarios have the following success criteria:

\begin{itemize}
\item \textbf{Leader Election}:
    \begin{enumerate}
    \item A leader is upon initiate start up of the system.
        \begin{enumerate}
        \item The user starts the program.
        \item Server $S$ times out.
        \item $S$ converts to candidate.
        \item $S$ receives a majority vote and converts to leader.
        \end{enumerate}
    \item A new leader must be elected if the current leader fails.
        \begin{enumerate}
        \item The user starts the program.
        \item A server $L$ is elected as leader.
        \item The user crashes $L$ at run-time.
        \item Server $S$ times out and start a new election.
        \end{enumerate}
    \end{enumerate}
\item \textbf{Log Replication}:
    \begin{enumerate}
    \item Log entry is replicated through the system.
        \begin{enumerate}
        \item The user starts the program.
        \item A server $L$ is elected as leader.
        \item The user requests that a value $x$ is replicated.
        \item $L$ replicates $x$ such that every log contains $x$ in their log at the correct term and index.
        \end{enumerate}
    \item Awoken follower get its log updated.
        \begin{enumerate}
        \item The user starts the program.
        \item A server $L$ is elected as leader.
        \item The user requests that a value $x$ is replicated.
        \item The user crashes a server $S$.
        \item The user requests that a value $y$ is replicated.
        \item The user wakes up $S$.
        \item $L$ updates $S$'s log such that it contains $y$ also.
        \end{enumerate}
    \end{enumerate}
\item \textbf{Safety}:
    \begin{enumerate}
    \item There is at most one leader at any given term.
    \item Leader never overwrites its own log but only appends on to it.
    \item Logs of every servers match each other up to their latest common index in their logs.
    \item The log of a leader contains all previous log entries of leader of previous terms.
    \item A server's log must be up to date with the leaders upon uptading it.
    \end{enumerate})
\end{itemize}

The last scenarios about safety are hard to informally validate since the program simulates a concurrent system, in which the utilisation of a formal verification tool would be necessary, which is out of scope of this project. %ok?.

%Scenarier
    % - Log replication
        % - Log entry is replicated throughout the system
        % - Update log of follwer who wakes up
    % - New leader election upon leader crash
    % - No majority vote possible => unavailable system
    % - 
    
% section evaluation_and_testing (end)
